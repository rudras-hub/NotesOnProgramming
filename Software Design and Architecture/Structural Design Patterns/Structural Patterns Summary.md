# Summary of Structural Design Patterns

## **Adapter**
![Adapter Pattern](/images/Adapter.png)

Use Case:
- How can a class be reused that does not have an interface that a client requires?
- How can classes that have incompatible interfaces work together?
- How can an alternative interface be provided for a class?
<div class="page"/>

## **Bridge**
![Bridge Pattern](/images/Bridge.png)

Use Case:
- An abstraction and its implementation should be defined and extended independently from each other.
- A compile-time binding between an abstraction and its implementation should be avoided so that an implementation can be selected at run-time.
<div class="page"/>

## **Composite**
![Composite Pattern](/images/Composite.png)

Use Case:
- A part-whole hierarchy should be represented so that clients can treat part and whole objects uniformly.
- A part-whole hierarchy should be represented as tree structure.
<div class="page"/>

## **Decorator**
![Decorator Pattern](/images/Decorator.png)

Use Case:
- Responsibilities should be added to (and removed from) an object dynamically at run-time.
- A flexible alternative to sub-classing for extending functionality.
<div class="page"/>

## **Facade**
![Facade Pattern](/images/Facade.png)

Use Case:
- To make a complex subsystem easier to use.
- The dependencies on a subsystem should be minimized.


## **Flyweight**
*Not used much; to be added later, if required.*
<div class="page"/>

## **Proxy**
![Proxy Pattern](/images/Proxy.png)

Use Case: 
- The access to an object should be controlled
- Checking preconditions before operations on the real object are invoked.

